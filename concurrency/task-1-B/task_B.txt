Проверим взаимное исключение:
Первый поток всегда сразу же войдет в критическую секцию, т.к. в этот момент thread_count == 0.
Далее, когда другой поток заходит в секцию ожидания, он сначала атомарно увеличивает thread_count, затем атомарно уменьшает. Чтобы какой-то из потоков зашел в критическую секцию, количество увеличений счетчика должно быть меньше количества уменьшений (т.к. первый прошедший в критическую секцию поток сделал значение счетчика равным 1, а для прохода в критическую секцию нужно вернуть значение 0), а это невозможно по причине того, что каждое уменьшение счетчика следует за его увеличением. Поэтому, пока первый поток не выйдет из критической секции, значение счетчика не опустится ниже 1.

Но свобода от взаимной блокировки не гарантируется. Рассмотрим 3 потока:
	Поток 1		|	Поток 2		|	Поток 3
    thread_count = 1	|			|
//зашел в крит.секцию	|			|
			|  thread_count = 2	|
			| //увеличил		|
			|			|   thread_count = 3
			|			| //увеличил
    thread_count = 2	|			|
//вышел оттуда		|			|
			|  thread_count = 1 	|
			| //уменьшил		|
			|  thread_count = 2	| 
			| //увеличил		|
			|			|   thread_count = 1
			|			| //уменьшил
			|			|  thread_count = 2 
			|			| //увеличил
			|  thread_count = 1 	|
			| //уменьшил		|
			|  thread_count = 2	| 
			| //увеличил		|
			|			|   thread_count = 1
			|			| //уменьшил
			|			|  thread_count = 2 
			|			| //увеличил

Возник deadlock, взаимную блокировку можно получить.
